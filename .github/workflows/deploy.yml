name: build-scan-deploy

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  PROJECT_ID: ${{ vars.PROJECT_ID }}
  REGION: ${{ vars.REGION }}
  AR_HOST: ${{ vars.AR_HOST }}              # e.g. europe-west1-docker.pkg.dev
  REPO: ${{ vars.REPO }}                    # e.g. services
  SERVICE_NAME: ${{ vars.SERVICE_NAME }}    # e.g. devsecops-demo
  RUNTIME_SA: ${{ vars.RUNTIME_SA }}        # runtime-sa@<project-id>.iam.gserviceaccount.com
  IMAGE_SHA: ${{ vars.SERVICE_NAME }}:${{ github.sha }}
  IMAGE_LATEST: ${{ vars.SERVICE_NAME }}:latest
  AR_IMAGE_SHA: ${{ vars.AR_HOST }}/${{ vars.PROJECT_ID }}/${{ vars.REPO }}/${{ vars.SERVICE_NAME }}:${{ github.sha }}
  AR_IMAGE_LATEST: ${{ vars.AR_HOST }}/${{ vars.PROJECT_ID }}/${{ vars.REPO }}/${{ vars.SERVICE_NAME }}:latest

jobs:
  build-scan-deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Auth to GCP via OIDC
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_DEPLOY_SA }}

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.AR_HOST }} --quiet

      - name: Build image (root Dockerfile)
        run: docker build -t "$IMAGE_SHA" -f Dockerfile .

      # Vulnerability scan (report only; does NOT fail the pipeline)
      - name: Trivy scan (report only)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ${{ env.IMAGE_SHA }}
          format: table
          exit-code: "0"
          severity: HIGH,CRITICAL

      - name: SBOM (CycloneDX)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ${{ env.IMAGE_SHA }}
          format: cyclonedx
          output: sbom.cdx.json

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: sbom.cdx.json

      - name: Tag & push to Artifact Registry
        run: |
          docker tag "$IMAGE_SHA" "$AR_IMAGE_SHA"
          docker tag "$IMAGE_SHA" "$AR_IMAGE_LATEST"
          docker push "$AR_IMAGE_SHA"
          docker push "$AR_IMAGE_LATEST"

      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy "$SERVICE_NAME" \
            --image "$AR_IMAGE_SHA" \
            --region "$REGION" \
            --service-account "$RUNTIME_SA" \
            --allow-unauthenticated \
            --platform managed \
            --port 8080 \
            --max-instances 3 \
            --timeout 300

      - name: Show Cloud Run URL
        run: gcloud run services describe "$SERVICE_NAME" --region "$REGION" --format='value(status.url)'

      - name: Smoke check (public URL; no /healthz)
        shell: bash
        run: |
          set -euo pipefail
          svc_url="$(gcloud run services describe "$SERVICE_NAME" --region "$REGION" --format='value(status.url)')"
          echo "Testing URL: $svc_url"

          echo "=== Service status before wait ==="
          gcloud run services describe "$SERVICE_NAME" --region "$REGION" --format='yaml(status)'

          # Wait up to 10 minutes for Ready=True (120 * 5s)
          attempts=0
          until gcloud run services describe "$SERVICE_NAME" --region "$REGION" \
                 --format='get(status.conditions[?type="Ready"].status)' | grep -q '^True$'; do
            attempts=$((attempts+1))
            if [ "$attempts" -gt 120 ]; then
              echo "Service did not become Ready in time" >&2
              exit 1
            fi
            echo "Waiting for Ready... ($attempts/120)"
            sleep 5
          done

          check() {
            local path="$1" expect="$2"
            local max=12
            for i in $(seq 1 $max); do
              resp="$(curl -fsS -L "$svc_url$path" -w '\n%{http_code}' --connect-timeout 5 --max-time 10 || true)"
              code="$(printf '%s\n' "$resp" | tail -n1)"
              body="$(printf '%s\n' "$resp" | sed '$d')"
              echo "[$path] http=$code payload=$(echo "$body" | head -c 120 | tr '\n' ' ')"
              if [ "$code" = "200" ]; then
                case "$expect" in
                  ok)        printf '%s' "$body" | tr -d '\r' | grep -q '"status":"ok"' && return 0 ;;
                  has_token) printf '%s' "$body" | grep -q 'APP_TOKEN=' && return 0 ;;
                esac
              fi
              sleep $(( i < 6 ? 3 : 6 ))
            done
            echo "Check $path failed after $max attempts" >&2
            echo "Last body:"; echo "$body"
            return 1
          }

          # Do NOT use /healthz on *.a.run.app — it's intercepted by Google Frontend
          check "/"     ok
          check "/info" has_token

          echo "Cloud Run smoke passed ✅"

      # Optional debug (doesn't fail the job). To see logs, the deploy SA needs roles/logging.viewer.
      - name: Debug — service/revision conditions & logs
        if: failure()
        continue-on-error: true
        run: |
          set -x
          gcloud run services describe "$SERVICE_NAME" --region "$REGION" \
            --format='yaml(spec.template.spec.containers[0].image,status.conditions,status.traffic)'

          latest_rev="$(gcloud run revisions list --service="$SERVICE_NAME" --region "$REGION" --format='value(name)' --limit=1)"
          echo "Latest revision: $latest_rev"
          gcloud run revisions describe "$latest_rev" --region "$REGION" --format='yaml(status.conditions)'

          echo "Last few request logs (requires roles/logging.viewer on the deploy SA):"
          gcloud logging read \
            "resource.type=cloud_run_revision AND resource.labels.service_name=$SERVICE_NAME" \
            --project "$PROJECT_ID" --limit 30 --format='value(timestamp,textPayload)' || true
